[//]: # (## Declerative approach to adding clusters to argoCD)

[//]: # ()
[//]: # (to be able to use workload identity federation to auto add clusters to argoCD setup a few things are required.)

[//]: # (In the example below I will show you how to overlay everything required using kustomize.)

[//]: # ()
[//]: # (&nbsp;)

[//]: # ()
[//]: # (1. Create the neccessary UMI's in azure and make sure they have to proper rights. Example of this can be found in squad-foundation-azure-AWS/envs/hub/aks-tooling/iam.tf & locals.tf. this will involve using the federadated credentials module to create a umi with federated credentials.)

[//]: # ()
[//]: # ()
[//]: # (2. Set annotations on argocd-server & argocd-application-controller service accounts like so, use the client-id generated by terraform)

[//]: # ( ```YAML)

[//]: # (apiVersion: v1)

[//]: # (kind: ServiceAccount)

[//]: # (metadata:)

[//]: # (  namespace: argocd)

[//]: # (  annotations:)

[//]: # (    azure.workload.identity/client-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx)

[//]: # (    azure.workload.identity/tenant-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx)

[//]: # (  name: argocd-server)

[//]: # (---)

[//]: # (apiVersion: v1)

[//]: # (kind: ServiceAccount)

[//]: # (metadata:)

[//]: # (  namespace: argocd)

[//]: # (  annotations:)

[//]: # (    azure.workload.identity/client-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx)

[//]: # (    azure.workload.identity/tenant-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx)

[//]: # (  name: argocd-application-controller)

[//]: # (```)

[//]: # ()
[//]: # (&nbsp;)

[//]: # ()
[//]: # (3. Set `azure.workload.identity/use = "true"` annotation on argocd-server deployment & argocd-application-controller)

[//]: # ( ```YAML)

[//]: # (apiVersion: apps/v1)

[//]: # (kind: Deployment)

[//]: # (metadata:)

[//]: # (  namespace: argocd)

[//]: # (  name: argocd-server)

[//]: # (spec:)

[//]: # (  template:)

[//]: # (    metadata:)

[//]: # (      annotations:)

[//]: # (        configmap.reloader.stakater.com/reload: "argocd-rbac-cm,argocd-cm,argocd-cmd-params-cm")

[//]: # (      labels:)

[//]: # (        azure.workload.identity/use: "true")

[//]: # (---)

[//]: # (apiVersion:  apps/v1)

[//]: # (kind: StatefulSet)

[//]: # (metadata:)

[//]: # (  namespace: argocd)

[//]: # (  name: argocd-application-controller)

[//]: # (spec:)

[//]: # (  template:)

[//]: # (    metadata:)

[//]: # (      annotations:)

[//]: # (        configmap.reloader.stakater.com/reload: "argocd-rbac-cm,argocd-cm,argocd-cmd-params-cm")

[//]: # (      labels:)

[//]: # (        azure.workload.identity/use: "true")

[//]: # (```)

[//]: # ()
[//]: # ()
[//]: # (&nbsp;)

[//]: # ()
[//]: # (4. Create a new cluster.yaml under the current directory like so, be sure to add the CA data or the connection won't work.)

[//]: # (some of the parameters are already in the pods env or default so you don't need to specify them but we are doing it regardless for doc purposes. )

[//]: # (the ca data required can be found in kubeconfig file after you have connected with it via the portal.)

[//]: # ()
[//]: # ( ```YAML)

[//]: # (apiVersion: v1)

[//]: # (kind: Secret)

[//]: # (metadata:)

[//]: # (  name: <name of the secret>)

[//]: # (  labels:)

[//]: # (    argocd.argoproj.io/secret-type: cluster)

[//]: # (type: Opaque)

[//]: # (stringData:)

[//]: # (  name: <name your cluster, this name will appear in argoCD>)

[//]: # (  server: <private endpoint of the kubernetes api server you want to add>)

[//]: # (  config: |)

[//]: # (    {)

[//]: # (      "execProviderConfig": {)

[//]: # (        "command": "argocd-k8s-auth",)

[//]: # (        "env": {)

[//]: # (          "AZURE_CLIENT_ID": "CLIENT_ID",)

[//]: # (          "AZURE_TENANT_ID": "TENANT_ID",)

[//]: # (          "AZURE_FEDERATED_TOKEN_FILE": "/var/run/secrets/azure/tokens/azure-identity-token",)

[//]: # (          "AZURE_AUTHORITY_HOST": "https://login.microsoftonline.com/",)

[//]: # (          "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",)

[//]: # (          "AAD_LOGIN_METHOD": "workloadidentity")

[//]: # (        },)

[//]: # (        "args": ["azure"],)

[//]: # (        "apiVersion": "client.authentication.k8s.io/v1beta1")

[//]: # (      },)

[//]: # (      "tlsClientConfig": {)

[//]: # (        "insecure": false,)

[//]: # (        "caData": "ca data from cluster you want to add, can be found in kubeconfig file after connecting with cluster")

[//]: # (      })

[//]: # (    })

[//]: # (```)

[//]: # ()
[//]: # (5. Previous step has been automated by the usage of external-secrets, we are using the operator to generate the secret based of the ca cert and the server url, these are found in the localfoundation keyvault after calling the aks terraform module in a certain way. Example can be found in poc-soa-eai-lenses.)

[//]: # (Instead of creating a normal secret we will create an external secret as shown below. All you need to do is change the name of the secrets reference with the correct clustername. You also need to make sure that the name set in the secret template field matches the existing cluster if it already exists.)

[//]: # (If you are deploying a fresh cluster this step can be ignored. I'm thinking about maybe creating some overlays for this..?)

[//]: # ()
[//]: # ( ```YAML)

[//]: # (apiVersion: external-secrets.io/v1beta1)

[//]: # (kind: ExternalSecret)

[//]: # (metadata:)

[//]: # (  name: poc-lenses-cluster-external-secret)

[//]: # (spec:)

[//]: # (  refreshInterval: 1h)

[//]: # (  secretStoreRef:)

[//]: # (    name: cluster-localfoundation-prd-store)

[//]: # (    kind: ClusterSecretStore)

[//]: # (  target:)

[//]: # (    name: ms-dev-aks-lenses-we-01-cluster-secret)

[//]: # (    creationPolicy: Owner)

[//]: # (    template:)

[//]: # (      type: Opaque)

[//]: # (      metadata:)

[//]: # (        labels:)

[//]: # (          argocd.argoproj.io/secret-type: cluster)

[//]: # (      data:)

[//]: # (        name: <choose or match current argocd cluster name>)

[//]: # (        server: "{{ .serverUrl }}")

[//]: # (        config: |)

[//]: # (          {)

[//]: # (            "execProviderConfig": {)

[//]: # (              "command": "argocd-k8s-auth",)

[//]: # (              "env": {)

[//]: # (                "AZURE_CLIENT_ID": "5bc5f230-293d-4d51-ac69-d4b56630a41a",)

[//]: # (                "AZURE_TENANT_ID": "24139d14-c62c-4c47-8bdd-ce71ea1d50cf",)

[//]: # (                "AZURE_FEDERATED_TOKEN_FILE": "/var/run/secrets/azure/tokens/azure-identity-token",)

[//]: # (                "AZURE_AUTHORITY_HOST": "https://login.microsoftonline.com/",)

[//]: # (                "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",)

[//]: # (                "AAD_LOGIN_METHOD": "workloadidentity")

[//]: # (              },)

[//]: # (              "args": ["azure"],)

[//]: # (              "apiVersion": "client.authentication.k8s.io/v1beta1")

[//]: # (            },)

[//]: # (            "tlsClientConfig": {)

[//]: # (              "insecure": false,)

[//]: # (              "caData": "{{ .caCert }}")

[//]: # (            })

[//]: # (          })

[//]: # (  data:)

[//]: # (    - secretKey: caCert)

[//]: # (      remoteRef:)

[//]: # (        key: secret/ms-dev-aks-lenses-we-01-ca-cert)

[//]: # (    - secretKey: serverUrl)

[//]: # (      remoteRef:)

[//]: # (        key: secret/ms-dev-aks-lenses-we-01-server-url)

[//]: # (```)


## Declarative Approach to Adding Clusters to ArgoCD

To leverage Workload Identity Federation for automatically adding clusters to ArgoCD, several preparatory steps are required. Below is a guide using Kustomize to overlay all the necessary configurations.

1. **Create Necessary UMIs in Azure:** First, set up User-Managed Identities (UMIs) in Azure, ensuring they possess the appropriate rights. This can be done by following the examples provided in `squad-foundation-azure-AWS/envs/hub/aks-tooling/iam.tf` and `locals.tf`. This step involves using the Federated Credentials module to create a UMI with federated credentials.

2. **Annotate ArgoCD Service Accounts:** Modify the `argocd-server` and `argocd-application-controller` service accounts with the required annotations. These annotations should include the `client-id` generated by Terraform. For example:
   ```YAML
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      namespace: argocd
      annotations:
        azure.workload.identity/client-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx
        azure.workload.identity/tenant-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx
      name: argocd-server
    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      namespace: argocd
      annotations:
        azure.workload.identity/client-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx
        azure.workload.identity/tenant-id: xxxxxxx-xxx-xxxx-xxxx-xxxxxxxxx
      name: argocd-application-controller
   ```

3. **Update ArgoCD Deployments with Azure Identity Annotation:** Ensure the `azure.workload.identity/use` annotation is set to `"true"` on both the `argocd-server` deployment and the `argocd-application-controller`. This is a crucial step for enabling Azure Workload Identity on these components.
   ```YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      namespace: argocd
      name: argocd-server
    spec:
      template:
        metadata:
          annotations:
            configmap.reloader.stakater.com/reload: "argocd-rbac-cm,argocd-cm,argocd-cmd-params-cm"
          labels:
            azure.workload.identity/use: "true"
    ---
    apiVersion:  apps/v1
    kind: StatefulSet
    metadata:
      namespace: argocd
      name: argocd-application-controller
    spec:
      template:
        metadata:
          annotations:
            configmap.reloader.stakater.com/reload: "argocd-rbac-cm,argocd-cm,argocd-cmd-params-cm"
          labels:
            azure.workload.identity/use: "true"
   ```

4. **Prepare Cluster Configuration File:** Create a new `cluster.yaml` file in the current directory. This file should include the CA data from your Kubernetes cluster, which is essential for establishing a secure connection. The CA data can typically be retrieved from the kubeconfig file after connecting to the cluster through the Azure portal.
   ```YAML
    apiVersion: v1
    kind: Secret
    metadata:
      name: <name of the secret>
      labels:
        argocd.argoproj.io/secret-type: cluster
    type: Opaque
    stringData:
      name: <name your cluster, this name will appear in argoCD>
      server: <private endpoint of the kubernetes api server you want to add>
      config: |
        {
          "execProviderConfig": {
            "command": "argocd-k8s-auth",
            "env": {
              "AZURE_CLIENT_ID": "CLIENT_ID",
              "AZURE_TENANT_ID": "TENANT_ID",
              "AZURE_FEDERATED_TOKEN_FILE": "/var/run/secrets/azure/tokens/azure-identity-token",
              "AZURE_AUTHORITY_HOST": "https://login.microsoftonline.com/",
              "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",
              "AAD_LOGIN_METHOD": "workloadidentity"
            },
            "args": ["azure"],
            "apiVersion": "client.authentication.k8s.io/v1beta1"
          },
          "tlsClientConfig": {
            "insecure": false,
            "caData": "ca data from cluster you want to add, can be found in kubeconfig file after connecting with cluster"
          }
        }
   ```

5. **Utilize External-Secrets for Automation:** The previous step of creating a Kubernetes secret can be automated using the External-Secrets operator. This approach involves configuring an ExternalSecret resource that references the necessary information stored in the Azure KeyVault. Adjust the names of the secrets and ensure that the `name` field in the `template` section of the ExternalSecret matches the name of the existing cluster in ArgoCD.
   ```YAML
    apiVersion: external-secrets.io/v1beta1
    kind: ExternalSecret
    metadata:
      name: poc-lenses-cluster-external-secret
    spec:
      refreshInterval: 1h
      secretStoreRef:
        name: cluster-localfoundation-prd-store
        kind: ClusterSecretStore
      target:
        name: ms-dev-aks-lenses-we-01-cluster-secret
        creationPolicy: Owner
        template:
          type: Opaque
          metadata:
            labels:
              argocd.argoproj.io/secret-type: cluster
          data:
            name: <choose or match current argocd cluster name>
            server: "{{ .serverUrl }}"
            config: |
              {
                "execProviderConfig": {
                  "command": "argocd-k8s-auth",
                  "env": {
                    "AZURE_CLIENT_ID": "5bc5f230-293d-4d51-ac69-d4b56630a41a",
                    "AZURE_TENANT_ID": "24139d14-c62c-4c47-8bdd-ce71ea1d50cf",
                    "AZURE_FEDERATED_TOKEN_FILE": "/var/run/secrets/azure/tokens/azure-identity-token",
                    "AZURE_AUTHORITY_HOST": "https://login.microsoftonline.com/",
                    "AAD_ENVIRONMENT_NAME": "AzurePublicCloud",
                    "AAD_LOGIN_METHOD": "workloadidentity"
                  },
                  "args": ["azure"],
                  "apiVersion": "client.authentication.k8s.io/v1beta1"
                },
                "tlsClientConfig": {
                  "insecure": false,
                  "caData": "{{ .caCert }}"
                }
              }
      data:
        - secretKey: caCert
          remoteRef:
            key: secret/ms-dev-aks-lenses-we-01-ca-cert
        - secretKey: serverUrl
          remoteRef:
            key: secret/ms-dev-aks-lenses-we-01-server-url
   ```

6. **Using Kustomize for Environment-Specific Variable Overlay:** This repository is structured to utilize Kustomize for easy management across different environments. Each environment is represented by its own folder within the Kustomize setup. To configure a new environment, follow these steps:

    - **Create a New Environment Folder:** Start by creating a new folder specific to your environment. This folder will contain custom configuration files for that particular environment.

    - **Update the Kustomization.yaml File:** In your newly created folder, add a `kustomization.yaml` file. This file will define how Kustomize should apply configurations specific to your environment. Use the following template as a starting point, modifying values as necessary:
      ```YAML
      apiVersion: kustomize.config.k8s.io/v1beta1
      kind: Kustomization
      
      namespace: argocd
      
      resources:
      - ../../../../base-clusters
      
      patches:
      - target:
          kind: ExternalSecret
        patch: |-
          - op: replace
            path: /metadata/name
            value: <argocd_cluster_name>-cluster-external-secret
          - op: replace
            path: /spec/target/name
            value: <aks_cluster_name>-cluster-secret
          - op: replace
            path: /spec/target/template/data/name
            value: <argocd_cluster_name>
          - op: replace
            path: /spec/data/0/remoteRef/key
            value: secret/<aks_cluster_name>-ca-cert
          - op: replace
            path: /spec/data/1/remoteRef/key
            value: secret/<aks_cluster_name>-server-url
      ```

    - **Customize for Your Environment:** In the `kustomization.yaml` file, replace placeholders like `<argocd_cluster_name>` and `<aks_cluster_name>` with appropriate values for your environment. This ensures that the configurations applied are specific to the cluster and environment you are working with.

    - **Integrate into the Main Kustomization File:** Finally, add a reference to this new folder in the main `kustomization.yaml` file located in the root directory. This step integrates your new environment-specific configuration into the broader Kustomize structure.